
Template:
Defines the following entities:
Kindergarten
Section
Educator
Child
Garment

And adds data to the database using these entities.
@NamedQuery is used
@OneToMany and @ManyToOne are used
Bidirectional relationships are used.
Creating data is done by explicit persisting, i.e. not cascading.

----------------

kindergarten1:
The attribute "name" in Child is mapped to another column name using @Column annotation.

kindergarten2:
Entity "Child" has attribues being CLOB and BLOB.

kindergarten3:
Entity "Child" has enums as ordinal and strings.

kindergarten4:
Entity "Child" has Temporal types, "date" and "timestamp" style.

kindergarten5:
Entity "Child" has Id/sequencegenerator defined in orm.xml.

kindergarten6:
cascade persist used for all entities.

kindergarten7:
Checking order of SQL operations generated by EntityManager operations: persist/remove in transaction vs remove/persist in transaction

kindergarten8:
Child relates to ElementCollection "ContactPerson" which is POJO, not entity

kindergarten9:
Child's relationship (@ManyToOne) to Educator is unidirectional (i.e. no @OneToMany back)

kindergarten10:
Child and CuddlyToy have @OneToOne relationship with each other.

kindergarten11:
Child has a @OneToMany relationship with CuddlyToy, and @OrderBy is used.

kindergarten12:
GUI where Child entity may be edited and EntityManager.merged back to persistenceContext. Child entity also has @Version attribute.

kindergarten13:
Entity "Garment" has bean validation constraint, which is forced to fail by 1) EJB container 2) JPA implementation.

kindergarten14:
Entity Child has a @OneToOne relationship with Entity Shelf. The foreign key is unique via @JoinColumn(unique=true)

kindergarten15:
Entity Child has unique=true, nullable=false contraints, as well as unique contraints on single columns and combinations (@UniqueConstraint)

kindergarten16:
Entity Section has cascadetype=Merge in its relationship with Entity Child. This application modifies both entities in detached state,
then merges the Section, which automatically causes the Child to be merged.

kindergarten17:
Entity Child has cascadetype=REMOVE in its relationship with Entity Garment. When a Child gets deleted, all its garments also get automatically deleted.

kindergarten18:
A demo that a caught NonUniqueResultException from query.getSingleResult() does not cause transaction rollback

kindergarten19:
Entity Child has a @ManyToMany relationship with entity Toy and the application assigns some toys to the childs.

kindergarten20:
A "paging" application browsing through all Child entities via setFirstResult and setMaxResults().

kindergarten21:
Uses a query returning just "raw columns" and not entities, and the query resut is then List of Object array.

kindergarten22:
Uses a query mapping entity Child to DTO ChildDTO using constructor expression.

kindergarten23:
Uses "join fetch" to eagerly load collections, also nested. See entity Kindergarten. It was necessary to use Set datatype to avoid MultipleBagFetchException.

kindergarten24:
A Child entity is prsisted without persisting or cascading a related Section, which causes IllegalStateException.

kindergarten25:
Instead of manually persisting related entities, Kindergarten.sections and Section.childs (both @OnetoMany) are set as cascade=CascadeType.PERSIST.

kindergarten26:
Updating and deleting entities using bulk update and bulk delete.

kindergarten27:
Entity Child has a Map "borrowedBooks" which maps from bookName to bookType. The map is stored as @ElementCollection.

kindergarten28:
Entity Child and entity Educator inherit from abstract class Person, using @Inheritance (SINGLE_TABLE).
It was necessary to use hibernate.discriminator.force_in_select to get this to work.

kindergarten29:
Like kindergarten28 but @Inheritance(JOINED).

kindergarten30:
Like kindergarten28 but @Inheritance(TABLE_PER_CLASS).

kindergarten31:
Using query for entity Child with load graph / fetch graph. Graphs are defined using annotations and programmatically via createEntityGraph,

kindergarten32:
Practicing JPQL:
  * A query which returns Educator of Child, given child name
  * Query which finds a garment with a name, given a child name
  * Query which returns all childs older than certain age
  * Query which returns a child with start date between 2016 and 2017
  * Query with several joins who return the Educators who have childs with garments with certain name.

kindergarten33:
Embeddables:
Child relates to @Embeddable Guardian and @ElementCollection of Embeddables: Parent.

kindergarten34:
Serializable:
Child relates to class Guardian which is persisted as Serializable.

kindergarten35:
Application uses "select for update via "LockModeType.PESSIMISTIC_WRITE" in a query.

kindergarten36:
Setting up a Child with 10K Garments, then read the Child again to add a single Garment, just to conclude the 10K Garments are not loaded.

kindergarten37:
Some basic native queries (createNativeQuery), using e.g. @SqlResultSetMapping.

kindergarten38:
Uses orpahnRemoval=true to get orphaned entities automaticaly deleted. I didn't get this example to work!
